# 手撸RPC

## 核心注解实现

### 服务提供者

极简的**服务提供者**注册到注册中心应提供的元数据信息：

1. 服务名称：提供服务的接口完整类名
2. 服务版本号：区分不同版本所提供的不同服务
3. 服务IP：服务所在应用程序主机所在ip
4. 服务端口：服务绑定的端口信息
5. 服务分组：对不同的服务进行分组，实现服务隔离的效果

其中，一个应用程序中的所提供的服务所在的IP和Port都是相同的，所以在配置文件中直接配置即可，而剩余三项：**服务名称、版本号、分组**，作为服务提供者注解的属性··



设定该注解是放在服务的**实现类**上。

```java
@RpcService(interfaceCale ...)
class SerendipityServiceImpl implement SerendipityService{
    ...
}
```

### 服务消费者

服务消费者更为负责，需要的属性有：

1. 注册中心地址
2. 注册中心类型
3. 负载均衡类型
4. 代理方式
5. 序列化方式
6. 版本号
7. 服务分组
8. 是否异步调用
9. 是否单项调用
10. 超时时间

消费的服务名称，从注册中心获取，而不是在本地定义

至于**注册中心地址、注册中心类型、负载均衡类型**可以在配置中统一进行配置，也可以为每一种方法进行客制化，这也是一个**亮点**所在。



该注解是在字段上的

```java
@RpcReference(...)
private SerendipityService serendipityService;
```



## RPC核心注解的扫描与解析

扫描指定目录下的所有文件，判断其类型，

过滤直接的实现：

​	扫描到某个文件，如果是.class结尾的文件，可以通过 clazz.getAnnotation()获得其是否被注解标注，若是，则可获得该注解的信息。同理，可以获得类中所有字段是否被注解标注，并获得注解的信息及属性。



TODO：解析



## 服务提供者

### 1. 收发消息

目标：

1. 实现自定义扫描注解的方式发布服务提供者的服务
2. 

### 2. 自定义协议

### 3. 自定义网络编解码

### 4. 模拟消费者与提供者数据交互

### 5. 服务提供者调用真实方法的实现

### 6. 服务提供者扩展支持Cglib调用
